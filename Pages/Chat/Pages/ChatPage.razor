@page "/chats/{ChatId:int}"
@inject ChatHubClient HubClient
@inject ILogger<ChatPage> Logger
@inject ChatJsInterop JsInterop

<PageTitle>@_chat?.Name</PageTitle>

<a class="no-decor" href="/Chats/">⬅️ Назад</a>

<div class="chat-container">
    
    <div class="navbar">
        <h4 class="order">@_chat?.Name</h4>
        
        <div class="user-list-container">
            <button class="send-button" @onclick="@ToggleUserList">Посмотреть пользователей чата</button>
            <div class="user-list @(_showUserList ? "show" : "")">
                @foreach (var user in _chat?.Users ?? Array.Empty<ChatUserModel>())
                {
                    <option value="@user.Id">@user.UserName</option>
                }
            </div>
        </div>
        @(HubClient.Connection.State == HubConnectionState.Connected ? "🟢" : "🔴")
    </div>
    
    <div id="my-container" class="chat-messages-container">
        @if (_chat is not null)
        {
            @foreach (var msg in _messages.Values
                .OrderBy(m => m.SentTime))
            {
                <ChatMessageComponent Message="@msg" IsAuthor="@(msg.Author.Id == _currentUser!.Id)"/>
            }
        }
    </div>
    <div class="chat-input-container">
        <textarea 
            class="message-input" 
            @bind="@_typedMessage" 
            @ref="@_inputRef"
            minlength="@Shared.Constants.Messages.MinMessageTextLength" 
            maxlength="@Shared.Constants.Messages.MaxMessageTextLength">
        </textarea>
        <button class="send-button" @onclick="@SendMessage">📨</button>
    </div>
</div>


@code {
    [Parameter]
    public int ChatId { get; set; }

    private ElementReference _inputRef;
    private bool _shouldPreventTyping;
    
    private ChatUserModel? _currentUser;
    private ChatModel? _chat;
    private Dictionary<int, ChatMessageModel> _messages = new();

    private string _typedMessage = string.Empty;
    
    private bool _showUserList;

    private void ToggleUserList()
    {
        _showUserList = !_showUserList;
    }
    
    protected override async Task OnInitializedAsync()
    {
        Logger.LogInformation("Subscribing to hub");
        HubClient.OnMessagePosted += AddMessage;
        HubClient.OnMessageDeleted += DeleteMessage;
        HubClient.OnMessageEdited += EditMessage;
            
        await HubClient.StartAsync();
        await PullMessagesAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await JsInterop.ScrollDown();
        await _inputRef.FocusAsync();
    }

    private async Task PullMessagesAsync()
    {
        _chat = await Storage.GetChatAsync(ChatId);
        _messages = _chat.Messages.ToDictionary(m => m.Id, m => m);
        _currentUser = await Storage.GetCurrentUserAsync();
    }

    private async Task SendMessage()
    {
        if (_chat is null) return;
        if (HubClient?.Connection is not { State: HubConnectionState.Connected }) return;
        if (string.IsNullOrWhiteSpace(_typedMessage)) return;
        
        var request = new PostChatMessageRequest
        {
            ChatId = _chat.Id,
            Text = _typedMessage,
        };

        try
        {
            await HubClient.PostMessage(request);
            _typedMessage = string.Empty;
        }
        catch (Exception e)
        {
            Console.Error.WriteLine(e);
            throw;
        }
    }

    private void AddMessage(PostChatMessageResult result)
    {
        Logger.LogInformation("Received event {Result}", result);
        _messages.Add(result.Message.Id, result.Message);
        StateHasChanged();
    }

    private void DeleteMessage(DeleteChatMessageResult result)
    {
        Logger.LogInformation("Deleting message with ID {Id}", result.MessageId);
        _messages.Remove(result.MessageId);
        StateHasChanged();
    }

    private void EditMessage(EditChatMessageResult result)
    {
        Logger.LogInformation("Editing message with ID {Id}", result.EditedMessage.Id);
        _messages[result.EditedMessage.Id] = result.EditedMessage;
        StateHasChanged();
    }
}

